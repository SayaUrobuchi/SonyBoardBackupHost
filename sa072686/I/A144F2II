§@ªÌ: DJWS (...) ¯¸¤º: sa072686
¼ÐÃD: Re: [°Q½×] 10135
®É¶¡: 2008/06/05 Thu 14:40:18

§Ú¬OÄ±±o§Ú¥Îªººtºâªk¨S¿ù
¥i¯à¬O¦]¬°¯BÂI¼Æ»~®t©Î¨ä¥L©_©Çªº­ì¦]
©Ò¥H³£¨S¿ìªkAC

³o¬O§Ú¸ò¤@¦ìAC¹Lªº¤H­n¨Óªºµ{¦¡½X
¤£¹L³o¬qµ{¦¡¼gªº«ÜÂø¶Ã
«ÜÃøÅªÀ´´N¬O¤F
¥t¥~...½Ð¤£­nª½±µ®³³o¬qµ{¦¡½X°e¥hjudge
ÁÂÁÂ¦U¦ì :)
(³o¬qµ{¦¡½X¬O¥Ø«eº]¤W¶]³Ì§Öªº¤@¤ä...XD)

#include <iostream>
#include <cmath>
#include <algorithm>
#define MAX 1000
using namespace std;

struct Point
{
    int idx;
    double x;
    double y;
    friend double dist(const Point &a,const Point &b)
    {
        double dx,dy;
        dx=a.x-b.x;
        dy=a.y-b.y;
        return sqrt(dx*dx+dy*dy);
    }
    friend double turn(Point p1,Point p2,Point p3)
    {
        return (p2.x-p3.x)*(p1.y-p3.y)-(p1.x-p3.x)*(p2.y-p3.y);
    }
}p[MAX+1],q[MAX+1];

Point minpoint;
double d1[MAX+1],d2[MAX+1];
int pos[MAX+1],expos[MAX+1];
int n,d,h,g;

int sign(double x)
{
    if (x < -0.000001)
    {
        return -1;
    }
    else if(x>0.000001)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

int compare(const void *a,const void *b)
{
    Point tempa=*(Point*)a;
    Point tempb=*(Point*)b;
    double x1,y1,x2,y2;
    x1=tempa.x-minpoint.x;
    x2=tempb.x-minpoint.x;
    y1=tempa.y-minpoint.y;
    y2=tempb.y-minpoint.y;
    if((fabs(x1)<0.000001)&&(fabs(y1)<0.000001))
    {
        return -1;
    }
    if((fabs(x2)<0.000001)&&(fabs(y2)<0.000001))
    {
        return 1;
    }
    if((fabs(x1)<0.000001)&&(fabs(x2)<0.000001))
    {
        if(y1*y2>0)
        {
            return 0;
        }
        else
        {
            return sign(y1);
        }
    }
    if((fabs(x1)<0.000001)&&(y1<0.000001))
    {
        return -1;
    }
    if((fabs(x2)<0.000001)&&(y2<0.0000001))
    {
        return 1;
    }
    if((fabs(x1)<0.000001)||(fabs(x2)<0.000001))
    {
        return sign(x2-x1);
    }
    else if(x1*x2<-0.000001)
    {
        return sign(x2);
    }
    else
    {
        return sign(x2*y1-x1*y2);
    }
}

void add_point()
{
    int i;
    d=0;
    for(i=1;i<=n;i++)
    {
        if(compare(&q[d],&q[i])==0)
        {
            if(dist(q[d],q[0])<dist(q[i],q[0]))
            {
                q[d]=q[i];
            }
        }
        else
        {
            q[++d]=q[i];
        }
    }
    d++;
}

void convex_hull()
{
    int i,j;
    if(d<=3)
    {
        for(i=0;i<d;i++)
        {
            pos[i]=q[i].idx;
        }
        pos[d]=pos[0];
        h=d+1;
        return;
    }
    for(i=0;i<3;i++)
    {
        pos[i]=q[i].idx;
    }
    h=j=3;
    while(j<d)
    {
        if(turn(p[pos[h-2]],p[pos[h-1]],q[j])<0.0)
        {
            pos[h++]=q[j++].idx;
        }
        else
        {
            h--;
        }
    }
    pos[h++]=pos[0];
}

int main()
{
    int i,j,k,t,gnum,gnew;
    double perimeter,minextra,mindist;
    bool flag;
    scanf("%d",&t);
    p[0].idx=0;
    p[0].x=p[0].y=0.0;
    for(k=0;k<t;k++)
    {
        scanf("%d",&n);
        minpoint.x=minpoint.y=0.0;
        for(i=1;i<=n;i++)
        {
            p[i].idx=i;
            scanf("%lf %lf",&p[i].x,&p[i].y);
            if((minpoint.x>p[i].x)||((p[i].x==minpoint.x)&&(minpoint.y>p[i].y)))
            {
                minpoint.x=p[i].x;
                minpoint.y=p[i].y;
            }
        }
        memcpy(q,p,sizeof(p));
        qsort(q,n+1,sizeof(q[0]),compare);
        add_point();
        convex_hull();
        perimeter=2.0;
        flag=false;
        for(i=0;i<h-1;i++)
        {
            perimeter=perimeter+dist(p[pos[i]],p[pos[i+1]]);
            if(pos[i]==0)
            {
                flag=true;
            }
        }
        if((flag==true)||(pos[h-1]==0))
        {
            printf("%.2f\n",perimeter);
            if(k<t-1)
            {
                printf("\n");
            }
            continue;
        }
        minpoint.x=minpoint.y=0.0;
        memcpy(q,p,sizeof(q));
        qsort(q,n+1,sizeof(q[0]),compare);
        add_point();
        g=1;
        minextra=2.0*dist(p[0],p[pos[0]])+dist(p[pos[1]],p[pos[0]]);
        for(i=0;i<h-1;i++)
        {
            while(q[g].idx!=pos[i])
            {
                if(++g==d)
                {
                    g=1;
                }
            }
            if(++g==d)
            {
                g=1;
            }
            expos[0]=0;
            expos[1]=pos[i];
            d1[0]=0;
            d1[pos[i]]=dist(p[0],p[pos[i]]);
            j=1;
            while(q[g].idx!=pos[i+1])
            {
                gnum=q[g].idx;
                if(turn(p[expos[j-1]],p[expos[j]],p[gnum])<0.0)
                {
                    d1[gnum]=d1[expos[j]]-dist(p[expos[j]],p[0])+dist(p[gnum],p[0])+dist(p[gnum],p[expos[j]]);
                    expos[++j]=gnum;
                    if(++g==d)
                    {
                        g=1;
                    }
                }
                else
                {
                    j--;
                }
            }
            if(--g==0)
            {
                g=d-1;
            }
            expos[0]=0;
            expos[1]=pos[i+1];
            d2[0]=0;
            d2[pos[i+1]]=dist(p[0],p[pos[i+1]]);
            j=1;
            while(q[g].idx!=pos[i])
            {
                gnum=q[g].idx;
                if(turn(p[expos[j-1]],p[expos[j]],p[gnum])>=0.0)
                {
                    d2[gnum]=d2[expos[j]]-dist(p[expos[j]],p[0])+dist(p[gnum],p[0])+dist(p[gnum],p[expos[j]]);
                    expos[++j]=gnum;
                    if(--g==0)
                    {
                        g=d-1;
                    }
                }
                else
                {
                    j--;
                }
            }
            mindist=2.0*dist(p[0],p[pos[i]])+dist(p[pos[i+1]],p[pos[i]]);
            while((gnum=q[g].idx)!=pos[i+1])
            {
                if(++g==d)
                {
                    g=1;
                }
                gnew=q[g].idx;
                if(mindist>d1[gnum]+d2[gnew])
                {
                    mindist=d1[gnum]+d2[gnew];
                }
            }
            mindist=mindist-dist(p[pos[i]],p[pos[i+1]]);
            if(minextra>mindist)
            {
                minextra=mindist;
            }
        }
        printf("%.2f\n",perimeter+minextra);
        if(k<t-1)
        {
            printf("\n");
        }
    }
    return 0;
}


--
[1m               [42m¢q[40m¢w¢¡                  ¢~¢w¢w¢w¢w¢w¢w¢w¢¡[m
[1m               ¢x  ¢x[1m¥[mx«[1mn¤@¤[m¤¡D¯[1mÁ¥§¤[mp¯[1m¸[m¡ý[1msony.TFcis.org¢x  ¢x[m
[1m                   ¢¢¢w¢w¢w¢w¢w¢w¢w¢w¢w¢£              ¢¢¢w[42m¢q[m
[1m               by DJWS from [m [1m140.112.90.81 (¥x¥_«Ò°ê¤j¾Ç)[m

¡¶ [1;30mDJWS [;33m§ï[m@[m2008/06/05 Thu 14:41:06[m
¡¶ [1;30mDJWS [;33m§ï[m@[m2008/06/05 Thu 14:41:19[m
¡¶ [1;30mDJWS [;33m§ï[m@[m2008/06/05 Thu 14:43:17[m
